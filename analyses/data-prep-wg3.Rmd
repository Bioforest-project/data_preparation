---
title: "Data preparation for Bioforest project"
author: "Camille Piponiot"
date: "2024-07-08"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
library(data.table)
library(BIOMASS)
library(ggplot2)
library(tidyverse)
library(entropart)
```

## Load all datasets 


```{r load-data}

# make sure all datasets are inside the folder raw-data and are names as output_data_sitename with no spaces

harmonized_files = list.files(path = "data/raw-data/", full.names = TRUE, pattern = "output_data")

data = 
  lapply(harmonized_files, read.csv) |> 
  rbindlist(use.names = TRUE, fill = TRUE) |> #why are there 2 columns lifestatus and lifestatus1 ?
  subset(LifeStatus %in% c(TRUE, NA, "Normal", "Recruit")) |> 
  subset(Diameter >= MinDBH) |> 
  subset(!(LifeForm %in% c("Palm", "Tree fan", "Death", "Vine"))) |>   # subsetting to remove life forms other                    
  # remove palm genera or vernacular names
  subset(!Genus %in% c("Oenocarpus", "Euterpe", "Astrocaryum")) |>
  subset(is.na(VernName) | VernName !="murumuru") |>   # Astrocaryum vernacular name in Paracou, only identified in the last censuses to vern name
  
  #subset(LifeForm %in% c("trees;palms","Tree","NA", "trees")) |>   # subsetting to remove life forms other                                                                               than trees (when indicated)
  
  #making modifications for each site as required
  # paracou
  subset(!(Site == "Paracou" & as.numeric(Plot) == 16)) |>
  subset(!(Site == "Paracou" & (Year %in% c(1996, 1998, 2000, 2002)))) |> # Paracou: remove partial census years
  subset(!(Site == "Paracou" & Year == 2010 & Plot == 15)) ## one fourth of plot 15 wasn't censused in 2010

print(summary(data))
table(data$Site)
```
We create a unique IdTree that combines the information on the site, plot, subplot (when the information exists) and tree tag or site-level tree id. 

```{r}
data[, IdTree := paste(Site, Plot, Subplot, IdTree, sep = "_")]
```


## Taxonomic correction

First we need to harmonise species names.

```{r}
data[Site == "Moju", VernName := iconv(VernName, from = "ISO-8859-1", to = "UTF-8")]
data[Site == "Moju", ScientificName := tstrsplit(VernName, "\\[|\\]")[[2]]]

data[, c("Genus", "Species") := tstrsplit(ScientificName, " |_")[1:2]]
```


This correction is specific to Paracou: the missing species names can be assigned on the basis of a correspondence with the vernacular names. 

```{r paracou-vername}
if (any(data$Site == "Paracou")) {
  
  if (!require(vernabota)) remotes::install_github("EcoFoG/vernabota", build_vignettes = TRUE); library(vernabota)
  
  dataParacou = subset(data, Site == "Paracou")
  dataParacou[, latin := paste(Genus, tstrsplit(Species, "_")[[1]])]
  
  # replace names of undetermined species with NA
  
  dataParacou[Species == "Indet.", latin := NA]
  
  # prepare data
  dataVern <- data.table(
    Plot = dataParacou$Plot,
    CodeAlive = dataParacou$Original_CodeAlive, 
    idTree = dataParacou$IdTree,  
    BotaCertainty = 4 - 
      2*grepl("Indet", dataParacou$Species) -
      2*grepl("Indet", dataParacou$Genus), ## temp
    BotaSource = ifelse(grepl("Indet", dataParacou$Genus), "Vern", "Bota"),
    VernName = dataParacou$VernName, 
    Family = dataParacou$Family, 
    Genus = dataParacou$Genus, 
    Species = dataParacou$Species
  ) |> vernabota::PrepData()
  
  # priors
  data(PriorAllFG_20220126)
  data(PriorParacouNew_20220126)
  data(PriorParacouOld_20220126)
  PriorAllFG = vernabota::PrepPrior(PriorAllFG_20220126)
  PriorParacouNew = vernabota::PrepPrior(PriorParacouNew_20220126)
  PriorParacouOld = vernabota::PrepPrior(PriorParacouOld_20220126)
  
  options = data.table(
    Plot = 1:15, 
    Prior = c("PriorParacouNew", "PriorParacouOld", "PriorParacouNew", "PriorAllFG", 
              "PriorParacouNew", "PriorParacouOld", "PriorParacouNew", "PriorAllFG", 
              "PriorParacouNew", "PriorParacouNew", "PriorAllFG", "PriorParacouOld", 
              "PriorParacouNew", "PriorAllFG", "PriorParacouOld")
  )
  
  dataVern = rbindlist(
    lapply(1:15, function(p) {
      rbindlist(suppressWarnings(vernabota::SimFullCom(
        Data2fill = dataVern[Plot == p], 
        prior = get(options[Plot==p]$Prior), 
        wp = 0.25, 
        NSim = 1, 
        eps = 0.01,
        Determ = TRUE
      )), idcol = "sim")
    })
  )
  
  data = merge(data, unique(dataVern[, c("idTree", "GensSpCor")]), 
               by.x = "IdTree", by.y = "idTree", all.x = TRUE)
  data[Site == "Paracou", c("Genus", "Species") := tstrsplit(GensSpCor, "-")[1:2]]
  data[,GensSpCor := NULL]
}

```

## DBH correction

### Add missing measurements 

If a tree is not measured in a census and then reappears in a later census, we can consider that it was just missed. In this case, a possible correction is to replace the missed measurements by interpolating with the last DBH before it was missed and the next one after. 

```{r interpolate-missing-trees}
# list all possible years of census for every tree
dfAll = data[, .(Year = seq(min(Year), max(Year))), .(Site, Plot, IdTree)] |> 
  # only keep years when the plot was really censused
  merge(unique(data[, c("Site", "Plot", "PlotArea", "Year")]), 
        by = c("Site", "Plot", "Year")) |> 
  # add DBH measurements
  merge(data[, c("IdTree", "Year", "Diameter")], 
        by = c("IdTree", "Year"), all = TRUE)
# spot missing measurements
IdMissing = dfAll[is.na(Diameter), unique(IdTree)]
# replace missing measurements 
dfAll[, DiameterCor := Diameter]
dfAll[IdTree %in% IdMissing, 
      DiameterCor := approx(Year, Diameter, Year)$y, 
      .(Site, Plot, PlotArea, IdTree)]
```

The following figure shows a sample of 12 trees corrected for missing DBH. The added DBH values are shown in red. 

```{r, fig.height = 8, fig.width = 10}
dfAll[IdTree %in% sample(IdMissing, 12)] |> 
  ggplot(aes(x=Year)) + 
  geom_point(aes(y=DiameterCor), col = 2) +
  geom_point(aes(y=Diameter)) + 
  facet_wrap(~paste(Site, Plot, IdTree), scales = "free")
```

```{r add-missing}
data = merge(
  data[, -"PlotArea"], dfAll[, -"Diameter"], 
  by = c("Site", "Plot", "IdTree", "Year"), all = TRUE)
```

It is important to note that this correction may introduce some bias, as it will not be able to detect missed trees in the first and last censuses of a plot. 


## Functional traits


```{r get-ft-value}
# get wood density 
data[, wd := BIOMASS::getWoodDensity(Genus, Species, stand = paste(Site, Plot, Year))$meanWD]
```

```{r plot-ft}
# plot distribution of wood density values
ggplot(data, aes(x=wd, fill = Site)) + 
  geom_density(alpha = 0.5) +
  labs(x = "Wood density (g.cm-3)") +
  theme_classic()
```

## Diversity indices

## DBH classes

We define size classes in intervals of 10 cm DBH: Class 1 will include trees with a DBH between 10 and 20 cm, class 2-trees between DBH of 21-30 cm, class 3- 31-40 cm. This will allow in calculation of variables for each size class, which can later be grouped if required.

For WP3: We do not allow large trees ($!=$) to return to the "small" size class, which occurs when the DBH of trees oscillates around 20 cm DBH.  


## DBH classes

We define two size classes: small trees with a DBH between 10 and 20 cm, and trees with a DBH $\geq$ 20 cm. 
We do not allow large trees to return to the "small" size class, which occurs when the DBH of trees oscillates around 20 cm DBH.  

```{r tree-size-class}
# small (10-20 cm DBH) and large (>= 20 cm DBH) trees
data[, class := 1 + (DiameterCor >= 20)]

# avoid trees switching between classes: once a tree is 'large' it cannot go back to 'small'
setorder(data, Year)
data[IdTree %in% data[class==2, unique(IdTree)], 
     YL := min(Year[class==2]), .(IdTree)] # YL: first year that a tree becomes large (defined by tree)
data[!is.na(YL) & Year > YL, class := 2] # after YL: a tree cannot become small again
```


```{r check-corr-class, fig.height= 6, fig.width=10}
# select a sample of 6 trees that have corrected size classes
CorrClass = sample(data[class == 2 & DiameterCor < 20, IdTree], 12)
subset(data, IdTree %in% CorrClass) |> 
  ggplot(aes(x = Year, y = DiameterCor, col = factor(class))) +
  geom_hline(yintercept = 20, lty=2) +
  geom_point() + 
  geom_line() + 
  facet_wrap(~paste(Site, Plot, IdTree), scales = "free") 
```

# Tree-by-tree stocks and fluxes

```{r census-interval}
setorder(data, Site, Plot, Year)
# get info on census intervals (by plot) to be used in flux calculation
dfYear = data[, .(Year = sort(unique(Year)),
                  firstCensus = min(Year),
                  NextCensus = c(sort(unique(Year))[-1], NA), 
                  dT = c(NA, diff(sort(unique(Year))))), # census interval between this census and the previous one
              .(Site, Plot)]
data = merge(data, dfYear, by = c("Site", "Plot", "Year"))
```

We divide trees into recruits (year of first measurement of a tree), other live trees, and dead trees (census when trees are recorded as dead: they are given a DBH = 0 cm). 

```{r tree-status}
# live trees
data[, status := "A"]

# trees on year of recruitment (or when changing classes): status = "R" for
# recruited tree. First year of measurement by tree and size class:
data[, recrYear := min(Year), .(Site, IdTree, class)] 
data[Year == recrYear & Year != firstCensus, status := "R"]

# mortality: add one measurement with DBH = 0 after tree death
data[, mortYear := max(NextCensus), .(Site, IdTree)]
dataMort = data[mortYear == NextCensus & !is.na(mortYear)]
dataMort[, `:=`(
  Year = NextCensus,
  status = "M",
  DiameterCor = 0,
  dT = NextCensus - Year
)]
data = rbind(data, dataMort)
```

We then calculate basal area per tree, and the tree-level change in basal area between two censuses. 

```{r ba-stocks-and-fluxes}
setorder(data, Year)
# basal area 
data[, ba := pi*(DiameterCor/200)**2]
# change in basal area (m2/yr) by tree
data[, dba := c(NA, diff(ba)/diff(Year)), .(IdTree)]
# for recruits: their basal area change is their basal area divided by the
# census interval before their recruitment
data[status == "R", dba := (ba-0)/dT]
```

# Plot-level variables

```{r data-aggregation}
dataPlot = 
  rbind(
    # basal area stocks and fluxes
    data[, .(
      stock = sum(ba)/unique(PlotArea), 
      mortality = sum(dba[status == "M"])/unique(PlotArea), 
      recruitment = sum(dba[status == "R"])/unique(PlotArea), 
      growth = sum(dba[status == "A"])/unique(PlotArea), 
      meas = "ba"), 
      .(Site, Plot, Year, class)],
    # mean wood density (weighted by ba) associated with stocks and fluxes
    data[, .(
      stock = weighted.mean(wd, ba), 
      mortality = weighted.mean(wd[status == "M"], abs(dba[status == "M"])), 
      recruitment = weighted.mean(wd[status == "R"], dba[status == "R"]), 
      growth = weighted.mean(wd[status == "A"], dba[status == "A"]), 
      meas = "wd_ba"
    ), .(Site, Plot, Year, class)],
    # 'stocks' and fluxes of tree abundance
    data[, .(
      stock = sum(status %in% c("R", "A"))/unique(PlotArea), 
      mortality = sum(status == "M")/unique(dT)/unique(PlotArea), 
      recruitment = sum(status == "R")/unique(dT)/unique(PlotArea), 
      growth = NA, 
      meas = "n"
    ), .(Site, Plot, Year, class)],
    # mean wood density associated with stocks and fluxes
    data[, .(
      stock = mean(wd), 
      mortality = mean(wd[status == "M"]), 
      recruitment = mean(wd[status == "R"]), 
      growth = NA, 
      meas = "wd_n"
    ), .(Site, Plot, Year, class)],
    # shannon diversity associated with stocks and fluxes
    data[, .(
      stock = Diversity(as.vector(table(ScientificName)), q=1, CheckArguments= FALSE, Correction = "None") |> suppressWarnings(), 
      mortality = Diversity(as.vector(table(ScientificName[status == "M"])), q=1, CheckArguments= FALSE, Correction = "None") |> suppressWarnings(), 
      recruitment = Diversity(as.vector(table(ScientificName[status == "R"])), q=1, CheckArguments= FALSE, Correction = "None") |> suppressWarnings(), 
      growth = Diversity(as.vector(table(ScientificName[status == "A"])), q=1, CheckArguments= FALSE, Correction = "None")|> suppressWarnings(), # diversity of survivors
      meas = "div1_n"
    ), .(Site, Plot, Year, class)]
  )

dataPlot = melt(dataPlot, measure.vars = c("stock", "mortality", "recruitment", "growth"))

# remove fluxes on the last census of measurement
dataPlot[variable != "stock" & Year == max(Year), value := NA, .(Site)]
```

## Add metadata

```{r}
# Paracou treatments
PlotInfo = data.frame(
  Site = "Paracou",
  Plot = 1:15, 
  treat = "logged"
)
# Paracou control plots
PlotInfo$treat[PlotInfo$Plot %in% c(1, 6, 11, 13:15)] = "control"
dataPlot = merge(PlotInfo, dataPlot, all.y = TRUE)
```


```{r save-results}
save(dataPlot, file = "data/derived-data/dataPlot_WG3.rda")
write.csv(dataPlot, file = "data/derived-data/dataPlot_WG3.csv", row.names = FALSE)
# save(dataPlot, file = "D:/github/Demography/data/derived-data/dataPlot_WG3.rda")
# write.csv(dataPlot, file = "D:/github/Demography/data/derived-data/dataPlot_WG3.csv", row.names = FALSE)
```

## Visualisation

```{r data-vis, fig.height=8, fig.width = 16}
subset(dataPlot, meas == "wd_ba") |>  
  subset(!(variable=="mortality" & Year < 1990)) |> # remove logging years with high mortality
  # subset(!(variable=="recruitment" & class==2)) |> # remove recruitment of trees > 20 cm DBH
  ggplot(aes(x=Year, y = value, group = paste(Plot, class), col=factor(class)))+
  geom_point() + geom_line() +
  lims(y = c(0, 1)) +
  facet_grid(variable ~ Site, scales = "free")
```
