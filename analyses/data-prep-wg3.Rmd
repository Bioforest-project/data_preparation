---
title: "Data preparation for Bioforest project"
author: "Camille Piponiot"
date: "2024-07-08"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
library(data.table)
library(BIOMASS)
library(ggplot2)
library(tidyverse)
```

## Load all datasets 


```{r load-data}

# make sure all datasets are inside the folder raw-data and are names as output_data_sitename with no spaces

harmonized_files = list.files(path = "data/raw-data/", full.names = TRUE, pattern = "output_data")

data = 
  lapply(harmonized_files, read.csv) |> 
  rbindlist(use.names = TRUE, fill = TRUE) |> #why are there 2 columns lifestatus and lifestatus1 ?
  subset(LifeStatus %in% c(TRUE, NA, "Normal", "Recruit")) |> 
  subset(Diameter >= MinDBH) |> 
  subset(!(LifeForm %in% c("Palm", "Tree fan", "Death", "Vine"))) |>   # subsetting to remove life forms other                    
  
  #subset(LifeForm %in% c("trees;palms","Tree","NA", "trees")) |>   # subsetting to remove life forms other                                                                               than trees (when indicated)
  #making modifications for each site as required
  
  # paracou
  # remove palms
  ##### do we need to remove these palms from other french guiana sites too?
  #####what if we remove all rows with the following genus?
  subset(!(Site == "Paracou" & Genus %in% c("Oenocarpus", "Euterpe", "Astrocaryum") & VernName =="murumuru")) |> 
  subset(!(Site == "Paracou" & as.numeric(Plot) == 16)) |>
  subset(!(Site == "Paracou" & (Year %in% c(1996, 1998, 2000, 2002)))) |> # Paracou: remove partial census years
  subset(!(Site == "Paracou" & Year == 2010 & Plot == 15)) |> ## one fourth of plot 15 wasn't censused in 2010

print(summary(data))
```


## Taxonomic correction

## DBH correction

## Functional traits

```{r get-ft-value}
# get wood density 
data[, wd := BIOMASS::getWoodDensity(Genus, Species, stand = Plot)$meanWD]
```

```{r plot-ft}
# plot distribution of wood density values
ggplot(data, aes(x=wd)) + 
  geom_histogram() +
  labs(x = "Wood density (g.cm-3)") +
  #facet_grid(. ~ Site) +
  theme_classic()
```

## Diversity indices

## DBH classes

We define size classes in intervals of 10 cm DBH: Class 1 will include trees with a DBH between 10 and 20 cm, class 2-trees between DBH of 21-30 cm, class 3- 31-40 cm. This will allow in calculation of variables for each size class, which can later be grouped if required.

For WP3: We do not allow large trees ($!=$) to return to the "small" size class, which occurs when the DBH of trees oscillates around 20 cm DBH.  


## DBH classes

We define two size classes: small trees with a DBH between 10 and 20 cm, and trees with a DBH $\geq$ 20 cm. 
We do not allow large trees to return to the "small" size class, which occurs when the DBH of trees oscillates around 20 cm DBH.  

```{r tree-size-class}
# small (10-20 cm DBH) and large (>= 20 cm DBH) trees
data[, class := 1 + (Diameter >= 20)]

# avoid trees switching between classes: once a tree is 'large' it cannot go back to 'small'
setorder(data, Year)
data[IdTree %in% data[class==2, unique(IdTree)], 
     YL := min(Year[class==2]), .(IdTree)] # YL: first year that a tree becomes large (defined by tree)
data[!is.na(YL) & Year > YL, class := 2] # after YL: a tree cannot become small again
```


```{r check-corr-class, fig.height= 6, fig.width=10}
# select a sample of 6 trees that have corrected size classes
CorrClass = sample(data[class == 2 & Diameter < 20, unique(IdTree)], 12)
subset(data, IdTree %in% CorrClass) |> 
  ggplot(aes(x = Year, y = Diameter, col = factor(class))) +
  geom_hline(yintercept = 20, lty=2) +
  geom_point() + 
  geom_line() + 
  facet_wrap(~IdTree, scales = "free") 
```

# Tree-by-tree stocks and fluxes

```{r census-interval}
setorder(data, Site, Plot, Year)
# get info on census intervals (by plot) to be used in flux calculation
dfYear = data[, .(Year = sort(unique(Year)),
                  firstCensus = min(Year),
                  NextCensus = c(sort(unique(Year))[-1], NA), 
                  dT = c(diff(sort(unique(Year))), NA)), # census interval between this census and the next
              .(Site, Plot)]
data = merge(data, dfYear, by = c("Site", "Plot", "Year"))
```

We divide trees into recruits (year of first measurement of a tree), other live trees, and dead trees (census when trees are recorded as dead: they are given a DBH = 0 cm). 

```{r tree-status}
# live trees
data[, status := "A"]

# trees on year of recruitment: status = "R" for recruited tree
data[, recrYear := min(Year), .(IdTree)] # first year of measurement by tree
data[Year == recrYear & Year != firstCensus, status := "R"]

# mortality: add one measurement with DBH = 0 after tree death
data[, mortYear := max(NextCensus), .(IdTree)]
dataMort = data[mortYear == NextCensus & !is.na(mortYear)]
dataMort[, `:=`(
  Year = NextCensus,
  status = "M",
  Diameter = 0,
  dT = NextCensus - Year
)]
data = rbind(data, dataMort)
```

We then calculate basal area per tree, and the tree-level change in basal area between two censuses. 

```{r ba-stocks-and-fluxes}
setorder(data, Year)
# basal area 
data[, ba := pi*(Diameter/200)**2]
# change in basal area (m2/yr) by tree
data[, dba := c(NA, diff(ba)/diff(Year)), .(IdTree)]
# for recruits: their basal area change is their basal area divided by the
# census interval before their recruitment
data[status == "R", dba := (ba-0)/dT]
```

# Plot-level variables

```{r data-aggregation}
dataPlot = 
  rbind(
    # basal area stocks and fluxes
    data[, .(
      stock = sum(ba)/unique(PlotArea), 
      mortality = sum(dba[status == "M"])/unique(PlotArea), 
      recruitment = sum(dba[status == "R"])/unique(PlotArea), 
      growth = sum(dba[status == "A"])/unique(PlotArea), 
      meas = "ba"), 
      .(Site, Plot, Year, class)],
    # mean wood density (weighted by ba) associated with stocks and fluxes
    data[, .(
      stock = weighted.mean(wd, ba), 
      mortality = weighted.mean(wd[status == "M"], abs(dba[status == "M"])), 
      recruitment = weighted.mean(wd[status == "R"], dba[status == "R"]), 
      growth = weighted.mean(wd[status == "A"], dba[status == "A"]), 
      meas = "wd_ba"
    ), .(Site, Plot, Year, class)],
    # 'stocks' and fluxes of tree abundance
    data[, .(
      stock = sum(status %in% c("R", "A"))/unique(PlotArea), 
      mortality = sum(status == "M")/unique(dT)/unique(PlotArea), 
      recruitment = sum(status == "R")/unique(dT)/unique(PlotArea), 
      growth = NA, 
      meas = "n"
    ), .(Site, Plot, Year, class)],
    # mean wood density associated with stocks and fluxes
    data[, .(
      stock = mean(wd), 
      mortality = mean(wd[status == "M"]), 
      recruitment = mean(wd[status == "R"]), 
      growth = NA, 
      meas = "wd_n"
    ), .(Site, Plot, Year, class)]
  )

dataPlot = melt(dataPlot, measure.vars = c("stock", "mortality", "recruitment", "growth"))

# remove fluxes on the last census of measurement
dataPlot[variable != "stock" & Year == max(Year), value := NA, .(Site)]
```

## Add metadata

```{r}
# Paracou treatments
PlotInfo = data.frame(
  Site = "Paracou",
  Plot = 1:15, 
  treat = "logged"
)
# Paracou control plots
PlotInfo$treat[PlotInfo$Plot %in% c(1, 6, 11, 13:15)] = "control"
dataPlot = merge(PlotInfo, dataPlot)
```


```{r save-results}
save(dataPlot, file = "data/derived-data/dataPlot_WG3.rda")
write.csv(dataPlot, file = "data/derived-data/dataPlot_WG3.csv")
```

## Visualisation

```{r data-vis, fig.height=10, fig.width = 6}
subset(dataPlot, meas == "wd_ba") |>  
  subset(!(variable=="mortality" & Year < 1990)) |> # remove logging years with high mortality
  subset(!(variable=="recruitment" & class==2)) |> # remove recruitment of trees > 20 cm DBH
  ggplot(aes(x=Year, y = value, group = paste(Plot, class), col=factor(class)))+
  geom_point() + geom_line() +
  facet_grid(variable ~ Site, scales = "free")
```
